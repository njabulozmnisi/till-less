# PDF Export Architecture

**Status:** Approved for Implementation
**Priority:** ğŸŸ¡ HIGH (Sprint 1, Week 2)
**Estimated Time:** 2-3 days
**Related PRD:** Â§7.1.5 Results & Reporting - "Export plan to PDF or email summary"

---

## 1. Overview

This document specifies the PDF export feature for optimization results, allowing users to save and share their shopping optimization plans offline.

**User Story:**
> As a user, I want to export my optimization results to PDF so that I can save it for reference while shopping or share it with family members.

---

## 2. Technology Stack

| Component | Technology | Version | Rationale |
|-----------|-----------|---------|-----------|
| PDF Generation | @react-pdf/renderer | 4.2.0 | React components â†’ PDF, server-side rendering, good TypeScript support |
| Alternative (if needed) | puppeteer | 23.10.4 | Headless Chrome, handles complex CSS, heavier dependency |

**Recommendation:** Start with `@react-pdf/renderer` for MVP (lighter, React-native). Upgrade to Puppeteer only if complex styling needed.

**Dependencies to Add:**
```json
// apps/backend/package.json
{
  "dependencies": {
    "@react-pdf/renderer": "4.2.0",
    "react": "18.3.1"
  }
}
```

---

## 3. Endpoint Specification

### **GET /api/optimization/{id}/export/pdf**

**Request:**
- **Method:** GET
- **Path Parameter:** `id` (UUID) - Optimization result ID
- **Auth:** Required (JWT token)

**Request Example:**
```bash
curl -X GET http://localhost:3001/api/optimization/550e8400-e29b-41d4-a716-446655440000/export/pdf \
  -H "Authorization: Bearer {token}" \
  --output optimization-report.pdf
```

**Response Success (200 OK):**
- **Content-Type:** `application/pdf`
- **Content-Disposition:** `attachment; filename="tillless-optimization-{id}.pdf"`
- **Body:** Binary PDF file

**Response Error (404 Not Found):**
```json
{
  "statusCode": 404,
  "error": "Not Found",
  "message": "Optimization result not found"
}
```

**Response Error (403 Forbidden):**
```json
{
  "statusCode": 403,
  "error": "Forbidden",
  "message": "You do not have access to this optimization result"
}
```

---

## 4. PDF Template Structure

### 4.1 Page Layout

**Format:** A4 Portrait (210mm Ã— 297mm)
**Margins:** 20mm all sides
**Font:** Helvetica (built-in PDF font)

### 4.2 Document Sections

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TillLess Optimization Report            â”‚
â”‚ Generated: 2025-01-19 14:30             â”‚
â”‚                                         â”‚
â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—   â”‚
â”‚ â•‘ RECOMMENDED STORE                 â•‘   â”‚
â”‚ â•‘ Checkers Sixty60                  â•‘   â”‚
â”‚ â•‘ Total Cost: R1,234.56             â•‘   â”‚
â”‚ â•‘ Savings vs Baseline: R180.00 (13%)â•‘   â”‚
â”‚ â•‘ Travel Cost: R45.00 (15km)        â•‘   â”‚
â”‚ â•‘ Estimated Time: 25 min            â•‘   â”‚
â”‚ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•   â”‚
â”‚                                         â”‚
â”‚ ITEM COMPARISON TABLE                   â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â” â”‚
â”‚ â”‚ Item     â”‚ Checkers â”‚ Pick n Payâ”‚...â”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¤ â”‚
â”‚ â”‚ Milk 2L  â”‚ R18.99 âœ“ â”‚ R19.50   â”‚   â”‚ â”‚
â”‚ â”‚ Bread    â”‚ R14.99 âœ“ â”‚ R15.50   â”‚   â”‚ â”‚
â”‚ â”‚ Eggs 12  â”‚ R32.50 âœ“ â”‚ R30.00   â”‚ â† â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”˜ â”‚
â”‚ âœ“ = Selected store                     â”‚
â”‚ â† = Cheaper elsewhere (travel cost)    â”‚
â”‚                                         â”‚
â”‚ SUBSTITUTIONS                           â”‚
â”‚ â€¢ Brand A Bread â†’ Albany Bread          â”‚
â”‚   Reason: Original out of stock         â”‚
â”‚   Price difference: +R0.50              â”‚
â”‚                                         â”‚
â”‚ PROMOTIONS APPLIED                      â”‚
â”‚ â€¢ Milk 2L: Buy 2, save R5               â”‚
â”‚ â€¢ Eggs: Xtra Savings price R32.50       â”‚
â”‚                                         â”‚
â”‚ ASSUMPTIONS                             â”‚
â”‚ â€¢ Prices last updated: 2025-01-19 08:00 â”‚
â”‚ â€¢ Loyalty cards active: Xtra Savings    â”‚
â”‚ â€¢ Travel cost: R3/km (15km = R45)       â”‚
â”‚ â€¢ Stock availability not verified       â”‚
â”‚                                         â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚ Generated by TillLess | tillless.co.za  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.3 Color Scheme

| Element | Color | Usage |
|---------|-------|-------|
| Header | #3b82f6 (Blue) | Title, section headers |
| Summary Card | #f5f5f5 (Light Gray) | Background for summary |
| Savings | #22c55e (Green) | Positive savings amounts |
| Warnings | #f59e0b (Amber) | Out of stock, substitutions |
| Text | #000000 (Black) | Primary text |
| Muted Text | #666666 (Gray) | Timestamps, notes |

---

## 5. Implementation

### 5.1 PDF Export Service

**File:** `apps/backend/src/optimization/pdf-export.service.ts`

```typescript
import { Injectable } from '@nestjs/common';
import {
  Document,
  Page,
  Text,
  View,
  StyleSheet,
  pdf,
  Font,
} from '@react-pdf/renderer';
import { OptimizationResult } from './optimization.types';

@Injectable()
export class PdfExportService {
  async generateOptimizationPdf(result: OptimizationResult): Promise<Buffer> {
    const doc = this.createDocument(result);
    const pdfBuffer = await pdf(doc).toBuffer();
    return pdfBuffer;
  }

  private createDocument(result: OptimizationResult) {
    return (
      <Document>
        <Page size="A4" style={styles.page}>
          {/* Header */}
          {this.renderHeader(result)}

          {/* Summary Card */}
          {this.renderSummaryCard(result)}

          {/* Item Comparison Table */}
          {this.renderItemComparisonTable(result)}

          {/* Substitutions */}
          {result.substitutions.length > 0 &&
            this.renderSubstitutions(result.substitutions)}

          {/* Promotions Applied */}
          {this.renderPromotions(result)}

          {/* Assumptions */}
          {this.renderAssumptions(result.assumptions)}

          {/* Footer */}
          {this.renderFooter()}
        </Page>
      </Document>
    );
  }

  private renderHeader(result: OptimizationResult) {
    return (
      <View style={styles.header}>
        <Text style={styles.title}>TillLess Optimization Report</Text>
        <Text style={styles.subtitle}>
          Generated: {new Date(result.createdAt).toLocaleString('en-ZA')}
        </Text>
      </View>
    );
  }

  private renderSummaryCard(result: OptimizationResult) {
    const { recommendedStore } = result;

    return (
      <View style={styles.summaryCard}>
        <Text style={styles.cardTitle}>Recommended Store</Text>
        <Text style={styles.storeName}>{recommendedStore.retailerName}</Text>

        <View style={styles.summaryRow}>
          <Text>Total Cost:</Text>
          <Text style={styles.price}>
            R{recommendedStore.totalCost.toFixed(2)}
          </Text>
        </View>

        <View style={styles.summaryRow}>
          <Text>Savings vs Baseline:</Text>
          <Text style={styles.savings}>
            R{recommendedStore.savingsVsBaseline.toFixed(2)} (
            {((recommendedStore.savingsVsBaseline / recommendedStore.totalCost) * 100).toFixed(1)}%)
          </Text>
        </View>

        <View style={styles.summaryRow}>
          <Text>Travel Cost:</Text>
          <Text>
            R{recommendedStore.travelCost.toFixed(2)} (
            {recommendedStore.travelDistance}km)
          </Text>
        </View>
      </View>
    );
  }

  private renderItemComparisonTable(result: OptimizationResult) {
    return (
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Item Comparison</Text>

        {/* Table Header */}
        <View style={styles.tableHeader}>
          <Text style={styles.tableHeaderCell}>Item</Text>
          <Text style={styles.tableHeaderCell}>Checkers</Text>
          <Text style={styles.tableHeaderCell}>Pick n Pay</Text>
          <Text style={styles.tableHeaderCell}>Shoprite</Text>
          <Text style={styles.tableHeaderCell}>Woolworths</Text>
          <Text style={styles.tableHeaderCell}>Makro</Text>
        </View>

        {/* Table Rows */}
        {result.itemComparisons.map((item, index) => (
          <View
            key={item.itemId}
            style={[styles.tableRow, index % 2 === 0 && styles.tableRowEven]}
          >
            <Text style={styles.tableCell}>{item.itemName}</Text>
            {this.renderPriceCells(item, result.recommendedStore.retailerId)}
          </View>
        ))}

        {/* Legend */}
        <View style={styles.legend}>
          <Text style={styles.legendText}>
            âœ“ = Selected store | â† = Cheaper elsewhere (inc. travel cost)
          </Text>
        </View>
      </View>
    );
  }

  private renderPriceCells(
    item: any,
    selectedRetailerId: string
  ) {
    const retailers = ['checkers', 'pick-n-pay', 'shoprite', 'woolworths', 'makro'];

    return retailers.map((retailerId) => {
      const priceData = item.prices[retailerId];

      if (!priceData || !priceData.inStock) {
        return (
          <Text key={retailerId} style={styles.tableCell}>
            â€”
          </Text>
        );
      }

      const isSelected = retailerId === selectedRetailerId;
      const loyaltyPrice = priceData.loyaltyPrice || priceData.price;

      return (
        <View key={retailerId} style={styles.priceCell}>
          <Text style={[styles.tableCell, isSelected && styles.selectedPrice]}>
            R{loyaltyPrice.toFixed(2)} {isSelected && 'âœ“'}
          </Text>
        </View>
      );
    });
  }

  private renderSubstitutions(substitutions: any[]) {
    return (
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Substitutions</Text>
        {substitutions.map((sub, idx) => (
          <View key={idx} style={styles.bulletItem}>
            <Text style={styles.bulletPoint}>â€¢</Text>
            <View style={styles.bulletContent}>
              <Text style={styles.substitutionText}>
                {sub.originalItemId} â†’ {sub.suggestedItem.name}
              </Text>
              <Text style={styles.substitutionReason}>
                Reason: {sub.suggestedItem.reason}
              </Text>
            </View>
          </View>
        ))}
      </View>
    );
  }

  private renderPromotions(result: OptimizationResult) {
    const promosApplied = result.itemComparisons
      .filter((item) => item.appliedPromos && item.appliedPromos.length > 0)
      .flatMap((item) =>
        item.appliedPromos.map((promo) => ({
          item: item.itemName,
          promo,
        }))
      );

    if (promosApplied.length === 0) return null;

    return (
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Promotions Applied</Text>
        {promosApplied.map((entry, idx) => (
          <View key={idx} style={styles.bulletItem}>
            <Text style={styles.bulletPoint}>â€¢</Text>
            <Text style={styles.bulletContent}>
              {entry.item}: {entry.promo}
            </Text>
          </View>
        ))}
      </View>
    );
  }

  private renderAssumptions(assumptions: string[]) {
    return (
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Assumptions</Text>
        {assumptions.map((assumption, idx) => (
          <View key={idx} style={styles.bulletItem}>
            <Text style={styles.bulletPoint}>â€¢</Text>
            <Text style={styles.bulletContent}>{assumption}</Text>
          </View>
        ))}
      </View>
    );
  }

  private renderFooter() {
    return (
      <View style={styles.footer}>
        <Text style={styles.footerText}>
          Generated by TillLess | tillless.co.za
        </Text>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  page: {
    padding: 30,
    fontFamily: 'Helvetica',
    fontSize: 10,
  },
  header: {
    marginBottom: 20,
    borderBottom: '2px solid #3b82f6',
    paddingBottom: 10,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#3b82f6',
  },
  subtitle: {
    fontSize: 10,
    color: '#666',
    marginTop: 5,
  },
  summaryCard: {
    backgroundColor: '#f5f5f5',
    padding: 15,
    marginBottom: 20,
    borderRadius: 5,
    border: '1px solid #e5e5e5',
  },
  cardTitle: {
    fontSize: 12,
    fontWeight: 'bold',
    marginBottom: 5,
    color: '#3b82f6',
  },
  storeName: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  summaryRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 5,
  },
  price: {
    fontWeight: 'bold',
    fontSize: 14,
  },
  savings: {
    fontWeight: 'bold',
    fontSize: 14,
    color: '#22c55e',
  },
  section: {
    marginBottom: 15,
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: 'bold',
    marginBottom: 10,
    color: '#3b82f6',
  },
  tableHeader: {
    flexDirection: 'row',
    backgroundColor: '#e5e5e5',
    padding: 5,
    borderBottom: '1px solid #000',
  },
  tableHeaderCell: {
    flex: 1,
    fontWeight: 'bold',
    fontSize: 9,
  },
  tableRow: {
    flexDirection: 'row',
    padding: 5,
    borderBottom: '1px solid #e5e5e5',
  },
  tableRowEven: {
    backgroundColor: '#fafafa',
  },
  tableCell: {
    flex: 1,
    fontSize: 9,
  },
  priceCell: {
    flex: 1,
  },
  selectedPrice: {
    fontWeight: 'bold',
    color: '#22c55e',
  },
  legend: {
    marginTop: 5,
    paddingTop: 5,
    borderTop: '1px solid #e5e5e5',
  },
  legendText: {
    fontSize: 8,
    color: '#666',
    fontStyle: 'italic',
  },
  bulletItem: {
    flexDirection: 'row',
    marginBottom: 5,
  },
  bulletPoint: {
    marginRight: 5,
    fontSize: 10,
  },
  bulletContent: {
    flex: 1,
  },
  substitutionText: {
    fontSize: 10,
    marginBottom: 2,
  },
  substitutionReason: {
    fontSize: 8,
    color: '#666',
    fontStyle: 'italic',
  },
  footer: {
    position: 'absolute',
    bottom: 20,
    left: 30,
    right: 30,
    borderTop: '1px solid #e5e5e5',
    paddingTop: 10,
  },
  footerText: {
    fontSize: 8,
    color: '#666',
    textAlign: 'center',
  },
});
```

### 5.2 Controller Integration

**File:** `apps/backend/src/optimization/optimization.controller.ts`

```typescript
import {
  Controller,
  Get,
  Param,
  Res,
  UseGuards,
  NotFoundException,
  ForbiddenException,
} from '@nestjs/common';
import { Response } from 'express';
import { AuthGuard } from '@nestjs/passport';
import { CurrentUser } from '../auth/decorators/current-user.decorator';
import { OptimizationService } from './optimization.service';
import { PdfExportService } from './pdf-export.service';

@Controller('optimization')
@UseGuards(AuthGuard('jwt'))
export class OptimizationController {
  constructor(
    private readonly optimizationService: OptimizationService,
    private readonly pdfExportService: PdfExportService
  ) {}

  @Get(':id/export/pdf')
  async exportPdf(
    @Param('id') id: string,
    @CurrentUser() user: { id: string },
    @Res() res: Response
  ) {
    // Fetch optimization result
    const result = await this.optimizationService.getById(id);

    if (!result) {
      throw new NotFoundException('Optimization result not found');
    }

    // Check authorization (user owns this optimization)
    if (result.userId !== user.id) {
      throw new ForbiddenException('You do not have access to this optimization result');
    }

    // Generate PDF
    const pdfBuffer = await this.pdfExportService.generateOptimizationPdf(result);

    // Set response headers
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader(
      'Content-Disposition',
      `attachment; filename="tillless-optimization-${id}.pdf"`
    );
    res.setHeader('Content-Length', pdfBuffer.length);

    // Send PDF
    res.send(pdfBuffer);
  }
}
```

---

## 6. Frontend Integration

### 6.1 RTK Query API

**File:** `apps/web/src/store/api/optimizationApi.ts`

```typescript
export const optimizationApi = baseApi.injectEndpoints({
  endpoints: (builder) => ({
    // ... existing endpoints

    exportOptimizationPdf: builder.mutation<Blob, string>({
      query: (id) => ({
        url: `/optimization/${id}/export/pdf`,
        method: 'GET',
        responseHandler: (response) => response.blob(),
      }),
    }),
  }),
});

export const {
  // ... existing hooks
  useExportOptimizationPdfMutation,
} = optimizationApi;
```

### 6.2 Export Button Component

**File:** `apps/web/src/components/features/optimization/ExportPdfButton.tsx`

```typescript
'use client'

import { useState } from 'react'
import { useExportOptimizationPdfMutation } from '@/store/api/optimizationApi'
import { Button } from '@/components/ui/button'
import { Download } from 'lucide-react'
import { useToast } from '@/components/ui/use-toast'

export function ExportPdfButton({ optimizationId }: { optimizationId: string }) {
  const [exportPdf, { isLoading }] = useExportOptimizationPdfMutation()
  const { toast } = useToast()

  const handleExport = async () => {
    try {
      const blob = await exportPdf(optimizationId).unwrap()

      // Create download link
      const url = window.URL.createObjectURL(blob)
      const link = document.createElement('a')
      link.href = url
      link.download = `tillless-optimization-${optimizationId}.pdf`
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
      window.URL.revokeObjectURL(url)

      toast({
        title: 'PDF Downloaded',
        description: 'Your optimization report has been saved',
      })
    } catch (error) {
      toast({
        title: 'Export Failed',
        description: 'Could not generate PDF. Please try again.',
        variant: 'destructive',
      })
    }
  }

  return (
    <Button onClick={handleExport} disabled={isLoading} variant="outline">
      <Download className="mr-2 h-4 w-4" />
      {isLoading ? 'Generating...' : 'Export PDF'}
    </Button>
  )
}
```

---

## 7. Testing Strategy

### 7.1 Unit Tests

**File:** `apps/backend/src/optimization/pdf-export.service.spec.ts`

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { PdfExportService } from './pdf-export.service';
import { OptimizationResult } from './optimization.types';

describe('PdfExportService', () => {
  let service: PdfExportService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [PdfExportService],
    }).compile();

    service = module.get<PdfExportService>(PdfExportService);
  });

  it('should generate PDF buffer', async () => {
    const mockResult: OptimizationResult = {
      id: 'opt-123',
      listId: 'list-123',
      recommendedStore: {
        retailerId: 'checkers',
        retailerName: 'Checkers Sixty60',
        totalCost: 1234.56,
        savingsVsBaseline: 180.0,
        travelCost: 45.0,
        travelDistance: 15,
      },
      itemComparisons: [
        {
          itemId: 'item-1',
          itemName: 'Milk 2L',
          prices: {
            checkers: { price: 18.99, inStock: true },
            'pick-n-pay': { price: 19.5, inStock: true },
          },
          selectedRetailer: 'checkers',
          appliedPromos: [],
        },
      ],
      substitutions: [],
      assumptions: ['Prices last updated: 2025-01-19 08:00'],
      createdAt: new Date().toISOString(),
    };

    const pdfBuffer = await service.generateOptimizationPdf(mockResult);

    expect(pdfBuffer).toBeInstanceOf(Buffer);
    expect(pdfBuffer.length).toBeGreaterThan(0);
    // PDF should start with %PDF header
    expect(pdfBuffer.slice(0, 4).toString()).toBe('%PDF');
  });

  it('should handle empty substitutions', async () => {
    const mockResult: OptimizationResult = {
      // ... minimal result
      substitutions: [],
    };

    const pdfBuffer = await service.generateOptimizationPdf(mockResult);
    expect(pdfBuffer).toBeInstanceOf(Buffer);
  });
});
```

### 7.2 Integration Tests

**File:** `apps/backend/test/pdf-export.e2e-spec.ts`

```typescript
import * as request from 'supertest';
import { Test } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import { AppModule } from '../src/app.module';

describe('PDF Export (e2e)', () => {
  let app: INestApplication;
  let authToken: string;
  let optimizationId: string;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    // Login and create optimization result
    const loginResponse = await request(app.getHttpServer())
      .post('/auth/login')
      .send({ email: 'test@example.com', password: 'password' });

    authToken = loginResponse.body.accessToken;

    // Create mock optimization result
    const optimizationResponse = await request(app.getHttpServer())
      .post('/optimization/run')
      .set('Authorization', `Bearer ${authToken}`)
      .send({ listId: 'test-list-id' });

    optimizationId = optimizationResponse.body.id;
  });

  it('/optimization/:id/export/pdf (GET) - should return PDF', async () => {
    const response = await request(app.getHttpServer())
      .get(`/optimization/${optimizationId}/export/pdf`)
      .set('Authorization', `Bearer ${authToken}`)
      .expect(200);

    expect(response.headers['content-type']).toBe('application/pdf');
    expect(response.headers['content-disposition']).toContain('attachment');
    expect(response.body).toBeInstanceOf(Buffer);
    expect(response.body.slice(0, 4).toString()).toBe('%PDF');
  });

  it('/optimization/:id/export/pdf (GET) - should return 404 for non-existent optimization', () => {
    return request(app.getHttpServer())
      .get('/optimization/non-existent-id/export/pdf')
      .set('Authorization', `Bearer ${authToken}`)
      .expect(404);
  });

  it('/optimization/:id/export/pdf (GET) - should return 403 for unauthorized access', async () => {
    // Login as different user
    const otherUserLogin = await request(app.getHttpServer())
      .post('/auth/login')
      .send({ email: 'other@example.com', password: 'password' });

    return request(app.getHttpServer())
      .get(`/optimization/${optimizationId}/export/pdf`)
      .set('Authorization', `Bearer ${otherUserLogin.body.accessToken}`)
      .expect(403);
  });

  afterAll(async () => {
    await app.close();
  });
});
```

### 7.3 Visual Testing

Manual testing checklist:
- [ ] PDF opens correctly in Adobe Reader
- [ ] PDF opens correctly in Chrome/Firefox built-in viewer
- [ ] All text is readable (no font issues)
- [ ] Colors render correctly
- [ ] Tables are aligned properly
- [ ] Substitutions section appears only when applicable
- [ ] Footer appears on bottom of page
- [ ] File size is reasonable (<500KB for typical report)

---

## 8. Performance Considerations

### 8.1 Generation Time

**Target:** < 2 seconds for typical optimization (60 items)
**Typical:** ~500ms-1s

**Optimization Strategies:**
- Pre-render static sections (header, footer templates)
- Cache font loading
- Use server-side rendering (already done with @react-pdf/renderer)

### 8.2 File Size

**Target:** < 500KB per PDF
**Typical:** 50-150KB for 60-item list

**Size Optimization:**
- Use built-in fonts (Helvetica) - no embedding needed
- Minimize images (use text/shapes instead)
- Compress if size > 500KB

### 8.3 Concurrent Requests

**Scenario:** Multiple users export PDF simultaneously

**Mitigation:**
- PDF generation is CPU-intensive
- Implement queue if > 10 concurrent exports
- Consider rate limiting (5 exports per minute per user)

---

## 9. Error Handling

### Error Scenarios

| Scenario | HTTP Status | Response |
|----------|-------------|----------|
| Optimization not found | 404 | `{ error: 'Not Found', message: 'Optimization result not found' }` |
| Unauthorized access | 403 | `{ error: 'Forbidden', message: 'You do not have access to this optimization result' }` |
| PDF generation fails | 500 | `{ error: 'Internal Server Error', message: 'Failed to generate PDF' }` |
| Missing data | 500 | `{ error: 'Internal Server Error', message: 'Incomplete optimization data' }` |

### Error Logging

```typescript
try {
  const pdfBuffer = await this.pdfExportService.generateOptimizationPdf(result);
  // ...
} catch (error) {
  this.logger.error(`PDF export failed for optimization ${id}`, error.stack);
  throw new InternalServerErrorException('Failed to generate PDF');
}
```

---

## 10. Security Considerations

### 10.1 Authorization

- âœ… **User Ownership Check:** Verify user owns optimization before export
- âœ… **JWT Authentication:** Required for endpoint access

```typescript
if (result.userId !== user.id) {
  throw new ForbiddenException('You do not have access to this optimization result');
}
```

### 10.2 Data Sanitization

- âœ… **No user-generated HTML:** @react-pdf/renderer uses React components (safe)
- âœ… **No script injection risk:** PDF format doesn't support JavaScript

### 10.3 Rate Limiting

Prevent abuse:
```typescript
@Throttle(5, 60) // 5 PDFs per 60 seconds
@Get(':id/export/pdf')
async exportPdf(...) { }
```

---

## 11. Alternative: Puppeteer Implementation

If complex styling needed (charts, custom fonts, complex layouts):

**Dependencies:**
```json
{
  "dependencies": {
    "puppeteer": "23.10.4"
  }
}
```

**Implementation:**
```typescript
import puppeteer from 'puppeteer';

async generateOptimizationPdfWithPuppeteer(result: OptimizationResult): Promise<Buffer> {
  const browser = await puppeteer.launch({ headless: true });
  const page = await browser.newPage();

  // Render HTML template
  const html = this.renderHtmlTemplate(result);
  await page.setContent(html);

  // Generate PDF
  const pdfBuffer = await page.pdf({
    format: 'A4',
    printBackground: true,
    margin: { top: '20mm', bottom: '20mm', left: '20mm', right: '20mm' },
  });

  await browser.close();
  return pdfBuffer;
}
```

**Trade-offs:**
- âœ… More flexible styling (full CSS support)
- âœ… Can render charts/graphs
- âŒ Heavier dependency (~300MB with Chromium)
- âŒ Slower generation (~2-3s vs ~500ms)
- âŒ More resource-intensive (memory, CPU)

**Recommendation:** Start with @react-pdf/renderer; switch to Puppeteer only if needed.

---

## 12. Monitoring & Logging

### Metrics to Track

- PDF export success rate
- Average generation time
- File size distribution
- Error rate by error type

### Logs

```typescript
this.logger.log(`PDF export started for optimization ${id}`);
this.logger.log(`PDF generated successfully, size: ${pdfBuffer.length} bytes, time: ${duration}ms`);
this.logger.error(`PDF export failed for optimization ${id}: ${error.message}`);
```

---

## 13. Success Criteria

- âœ… Endpoint `/api/optimization/{id}/export/pdf` returns PDF binary
- âœ… PDF opens correctly in all major viewers (Adobe, Chrome, Firefox)
- âœ… PDF contains all sections: header, summary, item table, substitutions, assumptions, footer
- âœ… Colors and styling render correctly
- âœ… Authorization check prevents unauthorized access
- âœ… Generation time < 2 seconds for 60-item list
- âœ… Frontend download works correctly in all browsers
- âœ… Unit tests achieve >80% coverage
- âœ… E2E tests pass for valid/invalid scenarios

---

## 14. Future Enhancements (Post-MVP)

1. **Email Delivery:**
   - Add endpoint: `POST /optimization/{id}/export/email`
   - Send PDF as attachment via SendGrid/Postmark

2. **Customization:**
   - User can select sections to include
   - User can add notes to PDF

3. **Multiple Formats:**
   - Excel export for price comparison
   - CSV export for raw data

4. **Branding:**
   - User can upload logo
   - Custom color schemes

---

## 15. Related Documentation

- **PRD:** `docs/prd.md` Â§7.1.5 (Results & Reporting - "Export plan to PDF")
- **Frontend Architecture:** `docs/architecture/frontend-architecture.md` (RTK Query optimizationApi)
- **Optimization Service:** `docs/architecture.md` Â§4.4 (Optimisation Service)
