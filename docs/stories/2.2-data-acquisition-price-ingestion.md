# Story 2.2: Data Acquisition Framework & Price Ingestion

**GitHub Issue:** #24
**Issue URL:** https://github.com/njabulozmnisi/till-less/issues/24
**Epic:** Sprint 2 - Retailer Management & Dynamic Configuration
**Status:** Ready for Development
**Estimate:** L (Large) - 3-4 days
**Story Points:** 8
**Assigned To:** Developer (James)

---

## Context

Implement the pluggable data acquisition framework with Strategy pattern to ingest price data from multiple sources. This continues Epic 2 (Retailer Management & Dynamic Configuration) by enabling automated price collection from retailers.

Currently, Story 2.1 has established the retailer management foundation with CRUD UI and seeded 5 SA retailers. The Prisma schema includes `RetailerIngestionConfig` and `IngestionStrategy` enum, but there's no actual ingestion implementation.

This story delivers the core ingestion framework, implements a web scraper strategy for Checkers, and stores price snapshots for optimization calculations (Epic 4).

**Dependencies:**
- ✅ Story 2.1 (Retailer Management) - Retailer CRUD and seed data complete
- ✅ Story 1.5 (Sentry Integration) - Error logging infrastructure ready
- ✅ Prisma Schema - RetailerIngestionConfig and RetailerItem models exist

---

## Goals

- Implement data acquisition Strategy pattern framework (IDataAcquisitionStrategy interface)
- Create Playwright-based web scraper strategy for Checkers
- Add ingestion config CRUD UI in admin (`/admin/retailers/:id/ingestion`)
- Store price snapshots in database (RetailerItem model)
- Add scheduled job infrastructure (cron with node-cron)
- Log ingestion attempts to Sentry for monitoring
- Add ingestion health metrics (successCount, failureCount, lastRun)
- Seed initial ingestion config for Checkers (Sixty60 website)

---

## Non-Goals

- Multiple scraper implementations (defer Pick n Pay to Story 2.3)
- PDF OCR ingestion (defer to Epic 5)
- API-based ingestion (defer to Story 2.3)
- Manual price entry UI (defer to Story 2.4)
- Product catalog seeding (defer to Story 2.5)
- Fuzzy product matching (defer to Story 2.5 - for MVP, use exact name match or create new products)
- Rate limiting and user-agent rotation (implement in Story 2.3 for production)

---

## Acceptance Criteria

1. **AC1: Data Acquisition Strategy Interface**
   - Given the framework exists, When a strategy is created, Then it implements `IDataAcquisitionStrategy` with `execute()` and `validate()` methods

2. **AC2: Checkers Web Scraper Strategy**
   - Given Checkers ingestion config exists, When the scraper runs, Then it extracts product name, price, and stock status from Checkers Sixty60 website

3. **AC3: Price Data Storage**
   - Given scraped data, When ingestion completes, Then price data is stored in `RetailerItem` table with proper retailer association

4. **AC4: Ingestion Config UI**
   - Given an admin views `/admin/retailers/:id/ingestion`, When they see the page, Then all ingestion configs for that retailer are displayed with health metrics

5. **AC5: Manual Ingestion Trigger**
   - Given an admin clicks "Run Now" on an ingestion config, When ingestion completes, Then health metrics update (lastRun, successCount/failureCount)

6. **AC6: Ingestion Logging**
   - Given an ingestion runs, When errors occur, Then they are logged to Sentry with retailer context, strategy type, and error details

7. **AC7: Scheduled Ingestion (Infrastructure)**
   - Given a cron schedule is configured, When the schedule triggers, Then ingestion runs automatically

---

## Tasks / Subtasks

### Backend - Strategy Pattern Framework

- [ ] **Task 1: Create Data Acquisition Interfaces** (AC: 1)
  - Create `apps/api/src/ingestion/interfaces/data-acquisition-strategy.interface.ts`
  - Define `IDataAcquisitionStrategy` interface with `execute()`, `validate()` methods
  - Define `IngestionResult` type (success, itemsIngested, errors)
  - Define `StrategyConfig` type (generic config structure)

- [ ] **Task 2: Create Strategy Factory** (AC: 1)
  - Create `apps/api/src/ingestion/strategy-factory.service.ts`
  - Implement factory method: `getStrategy(type: IngestionStrategy): IDataAcquisitionStrategy`
  - Register strategies (Scraper, API, Manual - implement Scraper only for now)
  - Throw error for unsupported strategies

- [ ] **Task 3: Install Playwright** (AC: 2)
  - Install `playwright` package: `pnpm add playwright`
  - Install browser binaries: `npx playwright install chromium`
  - Add Playwright to API dependencies
  - Configure headless mode in environment

### Backend - Scraper Strategy Implementation

- [ ] **Task 4: Create Base Scraper Strategy Class** (AC: 2)
  - Create `apps/api/src/ingestion/strategies/scraper.strategy.ts`
  - Implement `IDataAcquisitionStrategy`
  - Add Playwright browser launch logic
  - Add selector-based extraction helper methods

- [ ] **Task 5: Implement Checkers Scraper** (AC: 2, 3)
  - Create Checkers-specific scraper extending base
  - Navigate to Checkers Sixty60 product URL
  - Extract products using selectors from config JSON
  - Parse: name, price, inStock status
  - Handle pagination (first page only for MVP)

- [ ] **Task 6: Store Scraped Data** (AC: 3)
  - Create method to upsert `RetailerItem` records
  - Use unique constraint: `retailerId` + `sku` (or name if no SKU)
  - Update `price`, `loyaltyPrice`, `inStock`, `lastScraped`
  - Log items created vs updated

### Backend - Ingestion Module

- [ ] **Task 7: Create Ingestion Module Structure** (AC: 4, 5)
  - Create `apps/api/src/ingestion/ingestion.module.ts`
  - Create `apps/api/src/ingestion/ingestion.service.ts`
  - Create `apps/api/src/ingestion/ingestion.controller.ts`
  - Import PrismaModule and StrategyFactory

- [ ] **Task 8: Implement Ingestion Service** (AC: 5, 6)
  - Implement `runIngestion(configId)` method
  - Load config from database
  - Get strategy from factory
  - Execute strategy.validate() and strategy.execute()
  - Update health metrics (lastRun, successCount, failureCount)
  - Log to Sentry on errors

- [ ] **Task 9: Create Ingestion Controller Endpoints** (AC: 5)
  - Add `GET /api/retailers/:id/ingestion` - List configs
  - Add `POST /api/retailers/:id/ingestion/:configId/run` - Manual trigger (admin only)
  - Add proper authorization guards
  - Return health metrics in responses

### Backend - Scheduled Jobs

- [ ] **Task 10: Install node-cron** (AC: 7)
  - Install `node-cron` package: `pnpm add node-cron`
  - Install types: `pnpm add -D @types/node-cron`

- [ ] **Task 11: Create Scheduler Service** (AC: 7)
  - Create `apps/api/src/ingestion/scheduler.service.ts`
  - Load all active configs with `cadence` defined
  - Schedule cron jobs based on config.cadence
  - Call `ingestionService.runIngestion()` on schedule
  - Add logging for scheduled runs

- [ ] **Task 12: Initialize Scheduler on App Start** (AC: 7)
  - Call scheduler.init() in `apps/api/src/main.ts`
  - Ensure scheduler starts after Prisma connection

### Frontend - Ingestion Config UI

- [ ] **Task 13: Create RTK Query Ingestion API** (AC: 4, 5)
  - Create `apps/web/src/store/api/ingestionApi.ts`
  - Define endpoints: `getIngestionConfigs`, `runIngestionNow`
  - Add auto-refetch after manual trigger

- [ ] **Task 14: Create Ingestion Config Page** (AC: 4)
  - Create `apps/web/app/admin/retailers/[id]/ingestion/page.tsx`
  - Display ingestion configs in Shadcn UI Table
  - Columns: Strategy, Status, Last Run, Success/Failure Count, Actions
  - Show health metrics with badges

- [ ] **Task 15: Add Manual Trigger Button** (AC: 5)
  - Add "Run Now" button to each config row
  - Use RTK Query mutation to trigger ingestion
  - Show loading state during execution
  - Display toast notification on success/error

- [ ] **Task 16: Add Navigation Link** (AC: 4)
  - Update retailer detail page with "Ingestion" tab/link
  - Add to admin navigation breadcrumbs

### Database Seeding

- [ ] **Task 17: Seed Checkers Ingestion Config** (AC: 2)
  - Update `libs/database/src/seed.ts`
  - Add function `seedIngestionConfigs()`
  - Create config for Checkers with strategy: SCRAPER
  - Include config JSON with URL and selectors
  - Make idempotent with upsert

### Testing & Documentation

- [ ] **Task 18: Write Backend Tests** (AC: 1, 2, 3, 5, 6)
  - Unit tests for StrategyFactory
  - Unit tests for ScraperStrategy (mocked Playwright)
  - Unit tests for IngestionService
  - E2E tests for ingestion endpoints
  - Test Sentry logging on errors

- [ ] **Task 19: Write Frontend Tests** (AC: 4, 5)
  - Test ingestion config list renders
  - Test "Run Now" button triggers mutation
  - Test health metrics display correctly

- [ ] **Task 20: Update Documentation** (AC: All)
  - Document ingestion framework in README
  - Add scraper strategy guide
  - Document config JSON structure
  - Add troubleshooting section

---

## Dev Notes & Implementation Details

### Tech Stack Decisions

- **Web Scraping:** Playwright (supports JavaScript-heavy sites)
- **Job Scheduling:** node-cron (lightweight for MVP, upgrade to BullMQ in v2)
- **Error Monitoring:** Sentry (already integrated in Story 1.5)
- **Pattern:** Strategy Pattern for pluggable data sources

### Strategy Pattern Architecture

**Interface:**
```typescript
// apps/api/src/ingestion/interfaces/data-acquisition-strategy.interface.ts
export interface IngestionResult {
  success: boolean;
  itemsIngested: number;
  itemsUpdated: number;
  errors: string[];
  duration: number; // milliseconds
}

export interface IDataAcquisitionStrategy {
  validate(config: any): Promise<boolean>;
  execute(retailerId: string, config: any): Promise<IngestionResult>;
}
```

**Factory:**
```typescript
// apps/api/src/ingestion/strategy-factory.service.ts
import { Injectable } from '@nestjs/common';
import { IngestionStrategy } from '@prisma/client';
import { IDataAcquisitionStrategy } from './interfaces';
import { ScraperStrategy } from './strategies/scraper.strategy';

@Injectable()
export class StrategyFactory {
  constructor(private scraperStrategy: ScraperStrategy) {}

  getStrategy(type: IngestionStrategy): IDataAcquisitionStrategy {
    switch (type) {
      case 'SCRAPER':
        return this.scraperStrategy;
      default:
        throw new Error(`Strategy ${type} not implemented`);
    }
  }
}
```

### Scraper Strategy Implementation

**Base Scraper:**
```typescript
// apps/api/src/ingestion/strategies/scraper.strategy.ts
import { Injectable, Logger } from '@nestjs/common';
import { chromium, Page } from 'playwright';
import { PrismaService } from '@tillless/database';
import * as Sentry from '@sentry/nestjs';

@Injectable()
export class ScraperStrategy implements IDataAcquisitionStrategy {
  private readonly logger = new Logger(ScraperStrategy.name);

  constructor(private prisma: PrismaService) {}

  async validate(config: any): Promise<boolean> {
    return !!(config.url && config.selectors?.name && config.selectors?.price);
  }

  async execute(retailerId: string, config: any): Promise<IngestionResult> {
    const startTime = Date.now();
    const result: IngestionResult = {
      success: false,
      itemsIngested: 0,
      itemsUpdated: 0,
      errors: [],
      duration: 0,
    };

    let browser;
    try {
      // Launch Playwright browser
      browser = await chromium.launch({ headless: true });
      const page = await browser.newPage();

      // Navigate to retailer URL
      await page.goto(config.url, { waitUntil: 'networkidle' });

      // Extract products
      const products = await this.extractProducts(page, config.selectors);

      // Store in database
      for (const product of products) {
        const { created } = await this.upsertProduct(retailerId, product);
        if (created) result.itemsIngested++;
        else result.itemsUpdated++;
      }

      result.success = true;
    } catch (error) {
      this.logger.error(`Scraper failed: ${error.message}`, error.stack);
      result.errors.push(error.message);

      // Log to Sentry
      Sentry.captureException(error, {
        tags: { retailerId, strategy: 'SCRAPER' },
        extra: { config },
      });
    } finally {
      if (browser) await browser.close();
      result.duration = Date.now() - startTime;
    }

    return result;
  }

  private async extractProducts(page: Page, selectors: any) {
    return await page.$$eval(selectors.container || 'body', (elements, sel) => {
      return elements.map((el) => ({
        name: el.querySelector(sel.name)?.textContent?.trim(),
        price: parseFloat(el.querySelector(sel.price)?.textContent?.replace(/[^0-9.]/g, '')),
        inStock: !el.querySelector(sel.outOfStock),
      }));
    }, selectors);
  }

  private async upsertProduct(retailerId: string, product: any) {
    const existing = await this.prisma.retailerItem.findFirst({
      where: { retailerId, name: product.name },
    });

    if (existing) {
      await this.prisma.retailerItem.update({
        where: { id: existing.id },
        data: {
          price: product.price,
          inStock: product.inStock,
          lastScraped: new Date(),
        },
      });
      return { created: false };
    } else {
      await this.prisma.retailerItem.create({
        data: {
          retailerId,
          sku: `auto-${Date.now()}-${Math.random()}`, // Generate temp SKU
          name: product.name,
          price: product.price,
          inStock: product.inStock,
          lastScraped: new Date(),
        },
      });
      return { created: true };
    }
  }
}
```

### Ingestion Service

**Service:**
```typescript
// apps/api/src/ingestion/ingestion.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '@tillless/database';
import { StrategyFactory } from './strategy-factory.service';

@Injectable()
export class IngestionService {
  private readonly logger = new Logger(IngestionService.name);

  constructor(
    private prisma: PrismaService,
    private strategyFactory: StrategyFactory,
  ) {}

  async runIngestion(configId: string) {
    const config = await this.prisma.retailerIngestionConfig.findUniqueOrThrow({
      where: { id: configId },
      include: { retailer: true },
    });

    this.logger.log(`Running ingestion for ${config.retailer.name} (${config.strategy})`);

    try {
      // Get strategy
      const strategy = this.strategyFactory.getStrategy(config.strategy);

      // Validate config
      const isValid = await strategy.validate(config.config);
      if (!isValid) {
        throw new Error('Invalid configuration');
      }

      // Execute ingestion
      const result = await strategy.execute(config.retailerId, config.config);

      // Update health metrics
      await this.prisma.retailerIngestionConfig.update({
        where: { id: configId },
        data: {
          lastRun: new Date(),
          successCount: result.success ? { increment: 1 } : undefined,
          failureCount: !result.success ? { increment: 1 } : undefined,
          lastError: result.errors.join('; ') || null,
          lastErrorAt: result.errors.length > 0 ? new Date() : undefined,
        },
      });

      this.logger.log(`Ingestion completed: ${result.itemsIngested} ingested, ${result.itemsUpdated} updated`);

      return result;
    } catch (error) {
      // Update failure metrics
      await this.prisma.retailerIngestionConfig.update({
        where: { id: configId },
        data: {
          lastRun: new Date(),
          failureCount: { increment: 1 },
          lastError: error.message,
          lastErrorAt: new Date(),
        },
      });

      throw error;
    }
  }
}
```

### Scheduler Service

**Cron Scheduling:**
```typescript
// apps/api/src/ingestion/scheduler.service.ts
import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { PrismaService } from '@tillless/database';
import { IngestionService } from './ingestion.service';
import * as cron from 'node-cron';

@Injectable()
export class SchedulerService implements OnModuleInit {
  private readonly logger = new Logger(SchedulerService.name);
  private jobs: Map<string, cron.ScheduledTask> = new Map();

  constructor(
    private prisma: PrismaService,
    private ingestionService: IngestionService,
  ) {}

  async onModuleInit() {
    await this.initializeSchedules();
  }

  private async initializeSchedules() {
    const configs = await this.prisma.retailerIngestionConfig.findMany({
      where: { isActive: true, cadence: { not: null } },
      include: { retailer: true },
    });

    for (const config of configs) {
      this.scheduleJob(config.id, config.cadence, config.retailer.name);
    }

    this.logger.log(`Initialized ${configs.length} scheduled ingestion jobs`);
  }

  private scheduleJob(configId: string, cadence: string, retailerName: string) {
    const task = cron.schedule(cadence, async () => {
      this.logger.log(`Scheduled ingestion triggered for ${retailerName}`);
      try {
        await this.ingestionService.runIngestion(configId);
      } catch (error) {
        this.logger.error(`Scheduled ingestion failed: ${error.message}`);
      }
    });

    this.jobs.set(configId, task);
    this.logger.log(`Scheduled job for ${retailerName}: ${cadence}`);
  }
}
```

### Seed Data - Checkers Ingestion Config

**Seed Script:**
```typescript
// libs/database/src/seed.ts (add to existing seed)
async function seedIngestionConfigs(prisma: PrismaClient) {
  const checkers = await prisma.retailer.findUnique({
    where: { slug: 'checkers' },
  });

  if (!checkers) {
    console.log('⚠️  Checkers retailer not found, skipping ingestion config seed');
    return;
  }

  await prisma.retailerIngestionConfig.upsert({
    where: {
      id: 'checkers-scraper-config', // Use fixed ID for idempotency
    },
    update: {},
    create: {
      id: 'checkers-scraper-config',
      retailerId: checkers.id,
      strategy: 'SCRAPER',
      priority: 1,
      isActive: false, // Start disabled, admin enables manually
      config: {
        url: 'https://www.sixty60.co.za/search?query=milk',
        selectors: {
          container: '.product-card',
          name: '.product-name',
          price: '.product-price',
          outOfStock: '.out-of-stock',
        },
      },
      cadence: '0 2 * * *', // Daily at 2 AM
    },
  });

  console.log('✅ Seeded Checkers ingestion config');
}
```

### Frontend Ingestion Config Page

**Page Component:**
```tsx
// apps/web/app/admin/retailers/[id]/ingestion/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useGetIngestionConfigsQuery, useRunIngestionMutation } from '@/store/api/ingestionApi';
import { Table, TableHeader, TableBody, TableRow, TableHead, TableCell } from '@tillless/ui/components/table';
import { Button } from '@tillless/ui/components/button';
import { Badge } from '@tillless/ui/components/badge';
import { toast } from 'sonner';

export default function IngestionConfigPage() {
  const { id: retailerId } = useParams();
  const { data: configs, isLoading } = useGetIngestionConfigsQuery(retailerId as string);
  const [runIngestion, { isLoading: isRunning }] = useRunIngestionMutation();

  const handleRunNow = async (configId: string) => {
    try {
      await runIngestion({ retailerId: retailerId as string, configId }).unwrap();
      toast.success('Ingestion started successfully');
    } catch (error) {
      toast.error('Failed to start ingestion');
    }
  };

  if (isLoading) return <div>Loading...</div>;

  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-6">Ingestion Configurations</h1>

      <Table>
        <TableHeader>
          <TableRow>
            <TableHead>Strategy</TableHead>
            <TableHead>Status</TableHead>
            <TableHead>Last Run</TableHead>
            <TableHead>Success</TableHead>
            <TableHead>Failures</TableHead>
            <TableHead>Actions</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {configs?.map((config) => (
            <TableRow key={config.id}>
              <TableCell className="font-medium">{config.strategy}</TableCell>
              <TableCell>
                <Badge variant={config.isActive ? 'success' : 'secondary'}>
                  {config.isActive ? 'Active' : 'Inactive'}
                </Badge>
              </TableCell>
              <TableCell>{config.lastRun ? new Date(config.lastRun).toLocaleString() : 'Never'}</TableCell>
              <TableCell>{config.successCount}</TableCell>
              <TableCell>{config.failureCount}</TableCell>
              <TableCell>
                <Button
                  size="sm"
                  onClick={() => handleRunNow(config.id)}
                  disabled={isRunning}
                >
                  Run Now
                </Button>
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}
```

---

## Risks & Mitigations

- **Risk: Scraper breaks if Checkers changes HTML** → Mitigation: Store selectors in config JSON for easy updates, log errors to Sentry
- **Risk: Playwright resource usage** → Mitigation: Run scraper in background job, limit concurrency to 1 for MVP
- **Risk: Checkers blocks bot traffic** → Mitigation: Use headless: false for testing, add user-agent in Story 2.3
- **Risk: Price data staleness** → Mitigation: Store `lastScraped` timestamp, show age in admin UI
- **Risk: Ingestion failures** → Mitigation: Comprehensive error logging to Sentry, retry logic in Story 2.3

---

## Definition of Done

- [ ] All 20 tasks completed and tested
- [ ] All 7 acceptance criteria verified
- [ ] Strategy pattern framework implemented
- [ ] Checkers scraper working and extracting products
- [ ] Price data stored in RetailerItem table
- [ ] Admin ingestion config UI functional
- [ ] Manual "Run Now" trigger working
- [ ] Scheduled jobs infrastructure ready
- [ ] Sentry logging on errors
- [ ] Checkers ingestion config seeded
- [ ] Backend tests passing (unit + E2E)
- [ ] Frontend tests passing
- [ ] Documentation updated (README, architecture docs)
- [ ] Code reviewed and merged to `develop`
- [ ] Story 2.2 marked as complete in GitHub Issue #24

---

## Links & References

- **GitHub Issue:** https://github.com/njabulozmnisi/till-less/issues/24
- **Checkers Sixty60:** https://www.sixty60.co.za
- **Playwright Docs:** https://playwright.dev/docs/intro
- **Strategy Pattern:** https://refactoring.guru/design-patterns/strategy
- **node-cron:** https://www.npmjs.com/package/node-cron

---

**Created:** 2025-12-29
**Last Updated:** 2025-12-29
**Assigned To:** Developer (James)
**Reviewer:** Scrum Master (Bob)
