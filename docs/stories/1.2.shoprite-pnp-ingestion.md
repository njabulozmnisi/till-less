# Story 1.2: Shoprite & Pick n Pay Ingestion Rollout

## Status
Draft

## Story
**As a** TillLess data team member,
**I want** Shoprite and Pick n Pay ingestion pipelines implemented on the Temporalite → pg-boss → NestJS stack,
**so that** the canonical product registry gains timely coverage across additional Gauteng retailers for optimisation accuracy.

## Acceptance Criteria
1. Shoprite Playwright worker authenticates (when required), respects cadence and anti-bot rules, and emits payloads with promo badges, loyalty pricing, availability, and content hashes per the ingestion contract. [Source: docs/retailer-scraping-playbook.md#23-shoprite]
2. Pick n Pay Playwright worker captures Smart Shopper loyalty pricing, promo metadata, per-weight data, and availability fields, matching the shared payload schema. [Source: docs/retailer-scraping-playbook.md#22-pick-n-pay]
3. Temporalite workflows schedule both retailers using the grid (2–4h staples, nightly long tail) with retry/backoff policies and GitHub Actions cron fallback. [Source: docs/retailer-scraping-playbook.md#3-scheduling-grid-ops-ready][Source: docs/architecture/04-4-component-breakdown.md#41-data-ingestion-layer]
4. pg-boss consumer persists ≥400 active SKUs per retailer into `retailer_item` and `retailer_item_price`, storing loyalty/promo columns without duplicate rows (≤5% delta on rerun). [Source: docs/canonical-product-registry.md#3-field-reference-delta-focused]
5. Data quality sampling for each retailer confirms ≥90% of checked SKUs include promo/loyalty/availability data, with discrepancies logged for follow-up. [Source: docs/architecture/04-4-component-breakdown.md#43-canonical-product-registry-cpr]
6. Monitoring dashboards or logs surface scrape timestamp, SKU count, failure metrics per retailer with alerts for two consecutive failures, and runbook entries document triggers/troubleshooting. [Source: docs/architecture/04-4-component-breakdown.md#48-observability--ops][Source: docs/architecture/09-9-monitoring-alerting.md#9-monitoring--alerting]

## Tasks / Subtasks
- [ ] Extend Shoprite ingestion worker (AC: 1)
  - [ ] Implement TypeScript Playwright worker using Shoprite GraphQL endpoints, handling optional auth tokens and availability mapping while generating `content_hash`. [Source: docs/retailer-scraping-playbook.md#23-shoprite]
  - [ ] Place worker code under `packages/ingestion-workers/shoprite/` with shared utilities sourced from `packages/ingestion-shared/`. [Source: docs/architecture/source-tree.md#source-tree--module-layout]
  - [ ] Package worker for container execution and register Temporal activities with shared types package. [Source: docs/architecture/04-4-component-breakdown.md#41-data-ingestion-layer]
- [ ] Extend Pick n Pay ingestion worker (AC: 2)
  - [ ] Build Pick n Pay Playwright worker against SAP Hybris endpoints with Smart Shopper toggle, capturing promo fields and pack parsing details. [Source: docs/retailer-scraping-playbook.md#22-pick-n-pay]
  - [ ] Locate implementation in `packages/ingestion-workers/pnp/` and reuse shared helpers for throttling/content hash generation. [Source: docs/architecture/source-tree.md#source-tree--module-layout]
  - [ ] Ensure per-weight pricing and loyalty fields persist prior to queue publishing. [Source: docs/canonical-product-registry.md#3-field-reference-delta-focused]
- [ ] Configure Temporalite scheduling (AC: 3)
  - [ ] Define retailer-specific workflows with cadence from scheduling grid plus retry/backoff policies and GitHub Actions cron fallback job definitions. [Source: docs/retailer-scraping-playbook.md#3-scheduling-grid-ops-ready]
  - [ ] Verify registered schedules via Temporalite UI and document identifiers for runbooks. [Source: docs/architecture/04-4-component-breakdown.md#41-data-ingestion-layer]
- [ ] Update pg-boss consumer & Prisma mapping (AC: 4)
  - [ ] Add queue topics for Shoprite and Pick n Pay, reusing shared validation utilities while mapping promo badges, loyalty prices, and pack data into CPR tables. [Source: docs/architecture/04-4-component-breakdown.md#43-canonical-product-registry-cpr]
  - [ ] Keep consumer logic within `packages/queue-consumers/` and share contracts from `packages/types/ingestion.ts`. [Source: docs/architecture/source-tree.md#source-tree--module-layout]
  - [ ] Expand automated tests covering new retailer payloads and duplicate suppression using `content_hash`. [Source: docs/architecture/06-6-technology-stack.md#6-technology-stack]
- [ ] Validate data quality & completeness (AC: 4, 5)
  - [ ] Execute initial runs to reach ≥400 SKUs per retailer and confirm ≤5% new rows on rerun. [Source: docs/canonical-product-registry.md#4-matching--normalisation-rules-addenda]
  - [ ] Perform manual sampling (≥10 SKUs per retailer) to confirm promo/loyalty/availability accuracy and record discrepancies. [Source: docs/architecture/04-4-component-breakdown.md#43-canonical-product-registry-cpr]
- [ ] Enhance observability & runbooks (AC: 6)
  - [ ] Add per-retailer metrics/alerts for failure counts and stale timestamps, forwarding logs to Grafana/Logtail. [Source: docs/architecture/04-4-component-breakdown.md#48-observability--ops]
  - [ ] Update `docs/ops/` runbook with Shoprite/PnP trigger steps, verification queries, and known remediation actions. [Source: docs/architecture/09-9-monitoring-alerting.md#9-monitoring--alerting]

## Dev Notes
**Previous Story Insights**
- Story 1.1 delivers the baseline Temporalite + pg-boss infrastructure and Checkers ingestion pattern; reuse shared TypeScript types, queue consumer structure, and runbook conventions to maintain consistency. [Source: docs/stories/1.1.data-backbone-bootstrap.md]

**Retailer-Specific Guidance**
- Shoprite shares backend with Checkers but must identify itself via `retailer=shoprite`, handle session tokens when required, and parse `promotionBadges` plus `storeAvailability`. [Source: docs/retailer-scraping-playbook.md#23-shoprite]
- Pick n Pay exposes loyalty pricing when `smartshopper=true`; promo fields (`promotionType`, `promotionText`) and availability (`stock.stockLevelStatus`) must map exactly to CPR columns. [Source: docs/retailer-scraping-playbook.md#22-pick-n-pay]

**Data Models & Storage**
- CPR schema expects loyalty and promo metadata (`loyalty_price`, `promo_type`, `promo_badge_raw`) plus per-weight pricing fields for applicable SKUs; ensure migrations from Story 1.1 are applied before writing new data. [Source: docs/canonical-product-registry.md#3-field-reference-delta-focused]
- `content_hash` enforcement prevents duplicates across runs; consumer logic should skip inserts when hashes match prior snapshots. [Source: docs/canonical-product-registry.md#4-matching--normalisation-rules-addenda]

**Queue & Orchestration**
- Temporalite workflows orchestrate cadence and retries while pg-boss provides delivery semantics within Supabase Postgres; keep queue topic names distinct per retailer for observability. [Source: docs/architecture/04-4-component-breakdown.md#41-data-ingestion-layer]
- GitHub Actions cron fallback ensures nightly execution even if Temporalite is paused; document job identifiers in runbooks. [Source: docs/retailer-scraping-playbook.md#3-scheduling-grid-ops-ready]

**Observability & Ops**
- Monitoring must track ingestion success, SKU coverage, and failure counts; configure alerts on two consecutive failures or stale timestamps per monitoring strategy. [Source: docs/architecture/09-9-monitoring-alerting.md#9-monitoring--alerting]
- Runbooks in `docs/ops/` should add retailer-specific troubleshooting, auth token rotation procedures, and verification queries (SKU counts, promo coverage). [Source: docs/architecture/04-4-component-breakdown.md#48-observability--ops]

**Security & Secrets**
- Manage loyalty tokens and credentials via secrets manager (Supabase secrets or BetterAuth), never logging sensitive values during worker execution. [Source: docs/retailer-scraping-playbook.md#1-shared-principles]

**Project Structure Notes**
- Adhere to `docs/architecture/source-tree.md` so workers live under `packages/ingestion-workers/<retailer>/` and queue consumers remain in `packages/queue-consumers/`.

### Testing
- Implement Jest tests for worker parsing utilities and pg-boss consumer mapping to guarantee loyalty/promo fields persist as expected. [Source: docs/architecture/06-6-technology-stack.md#6-technology-stack]
- Validate Temporal workflows via testing environment to confirm retries and idempotency within performance envelope (<12 minutes ingest) described in non-functional considerations. [Source: docs/architecture/07-7-non-functional-considerations.md#7-non-functional-considerations]
- Manual QA should include Temporalite UI review plus Prisma/SQL queries confirming SKU counts and data completeness per retailer. [Source: docs/retailer-scraping-playbook.md#3-scheduling-grid-ops-ready]
- Key scenarios per testing strategy: worker parsing fixtures for loyalty/promo fields, consumer persistence tests, workflow retry exhaustion, alert firing on consecutive failures, and manual spot-check parity with live sites. [Source: docs/architecture/testing-strategy.md#testing-strategy]

## Change Log
| Date | Version | Description | Author |
| --- | --- | --- | --- |
| 2025-09-28 | v0.1 | Initial draft prepared by Scrum Master | Bob |

## Dev Agent Record
### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results
| Date | Reviewer | Outcome | Notes |
| --- | --- | --- | --- |
