# Story 1.2: Shoprite & Pick n Pay Ingestion Rollout

- **Status:** Draft
- **Epic:** 1 – Data Backbone Foundations
- **Related PRD Sections:** `docs/prd/05-5-scope-phase-1-mvp.md`, `docs/prd/07-7-detailed-requirements.md`
- **Related Architecture Sections:** `docs/architecture/03-3-high-level-architecture-overview.md`, `docs/architecture/04-4-component-breakdown.md`, `docs/architecture/06-6-technology-stack.md`

## Story Statement
As the TillLess data team, we need Shoprite and Pick n Pay ingestion pipelines using the standard Temporalite + pg-boss + NestJS pattern so that the canonical product registry maintains competitive coverage across major Gauteng retailers.

## Acceptance Criteria
- [ ] Playwright workers for Shoprite and Pick n Pay implement cadence and promo parsing rules defined in `docs/retailer-scraping-playbook.md`.
- [ ] Temporalite workflows scheduled to run each retailer per cadence grid (2–4h staples, nightly long-tail) with retry policies and GitHub cron fallback.
- [ ] pg-boss queues deliver payloads to the shared NestJS consumer, persisting ≥400 SKUs per retailer for target categories (staples, detergents, proteins) with loyalty pricing captured.
- [ ] Data quality checks ensure promo flags, loyalty prices, and availability fields populate for at least 90% of sampled SKUs.
- [ ] Monitoring dashboards or reports expose scrape timestamp, SKU count, and failure counts per retailer.
- [ ] Runbook updated with retailer-specific triggers and troubleshooting steps.

## Tasks & Subtasks
1. **Implement Shoprite Worker**
   - Build TypeScript Playwright script targeting Shoprite GraphQL endpoints; respect auth/session management.
   - Emit payloads conforming to ingestion schema (raw fields, promo metadata, loyalty prices).
2. **Implement Pick n Pay Worker**
   - Build TypeScript Playwright script covering SAP Hybris endpoints with Smart Shopper loyalty toggles.
   - Ensure `price_mode`, `price_per_uom`, promo badges captured before queue hand-off.
3. **Temporalite Workflow Definitions**
   - Define workflows per retailer with scheduling windows (2–4h daytime, nightly long-tail).
   - Register schedules in Temporalite and verify via UI.
4. **Queue Integration & Prisma Mapping**
   - Reuse `pg-boss` consumer to handle new retailer topics; add retailer-specific normalisation logic (brand dictionaries, pack parsing adjustments).
   - Expand automated tests for new mapping rules.
5. **Data Validation & QA**
   - Run initial harvests; confirm SKU counts, loyalty prices, promo coverage.
   - Spot-check 10 items per retailer against live site for accuracy.
6. **Monitoring & Documentation**
   - Add retailer metrics to dashboard/logs; configure alert thresholds.
   - Update runbook with retailer-specific commands, schedule identifiers, known issues.

## Implementation Notes for Dev Agent
- Share utilities for price parsing across retailers to avoid duplication.
- Coordinate with BetterAuth for secrets (loyalty tokens) via environment variables.
- Ensure queue topics/worker names unique per retailer to simplify monitoring.

## Testing & Validation
- Automated tests for new worker parsing logic and queue consumer mappings.
- Manual verification via Temporalite UI and Prisma queries for sample SKUs.
- Performance: each retailer run completes within target window (<12 minutes for ~500 SKUs).

## Dependencies
- Story 1.1 completed (pg-boss, Temporalite infrastructure, Checkers pipeline baseline).
- Requires retailer credentials/tokens stored in secrets manager.

## QA Checklist
- [ ] Provide Temporalite screenshots/logs for each retailer.
- [ ] Attach Prisma query outputs confirming SKU counts and promo fields.
- [ ] Runbook updated with Shoprite/PnP sections.

## Implementation Log
| Date | Author | Notes |
| --- | --- | --- |

## QA Results
| Date | Reviewer | Outcome | Notes |
| --- | --- | --- | --- |

## File Tracker
- _To be completed during implementation._
